{"version":3,"sources":["api/CSRFToken.tsx","parser/SongParser.ts","parser/LineParser.ts","parser/LyricParser.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["axios","defaults","xsrfCookieName","xsrfHeaderName","CSRFToken","SlideConvertMethod","csrftoken","name","cookieValue","document","cookie","cookies","split","i","length","replace","substring","decodeURIComponent","getCookie","type","value","splitArrayBySize","array","size","result","element","last","push","convertBodyToSlide","body","lineSize","tag","lines","map","join","LineCategory","SongParser","songParts","currentTag","title","flow","linkUrl","bodys","tagBodyMap","Map","bodysWithNoTag","comments","part","category","undefined","this","logDiscard","toUpperCase","console","error","slice","lastBody","concat","comment","filter","$0","flatMap","lineJoiner","Array","toSlideBodyOrder","slidesFromFlowTokens","splitAsTokens","token","get","slidesFromUntaggedBodys","method","withFlowOrder","toSlideFlowOrder","withBodyOrder","tagPatterns","flowTokenPatterns","isFlowToken","arg","some","pattern","test","separatorPatterns","scoreRange","titleSections","categoryScorer","empty","text","date","score","tokens","flowTokens","Math","ceil","separator","Line","inferedCategory","categories","$enum","getValues","reduce","current","checker","unknown","LineParser","songsCache","done","trim","lastLine","getSongParts","songs","currentIndex","currentPart","previousParts","isCompleteSong","splice","includes","firstBodyIndexAfterThis","findIndex","titleEndIndex","isTitleSection","getKeyOrDefault","forEach","line","index","start","end","convertSlideToFormText","slide","convertSongSlidesToFormText","slides","LyricParser","lineParser","songParsers","toSlides","App","formRef","useRef","textAreaRef","hiddenBodyRef","className","id","ref","action","onClick","formText","toFormText","submit","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6147da61.chunk.js","sourcesContent":["import React, { ReactElement } from \"react\";\nimport axios from \"axios\";\n\naxios.defaults.xsrfCookieName = \"csrftoken\";\naxios.defaults.xsrfHeaderName = \"X-CSRFToken\";\n\nfunction getCookie(name: string): string | null {\n  var cookieValue = null;\n  if (document.cookie && document.cookie !== \"\") {\n    var cookies = document.cookie.split(\";\");\n    for (var i = 0; i < cookies.length; i++) {\n      var cookie = cookies[i].replace(\" \", \"\");\n      //var cookie = jQuery.trim(cookies[i]); 당신이 만약 jQuery를 사용한다면, 위 코드 대신 이 코드를 사용하여도 좋다\n      if (cookie.substring(0, name.length + 1) === name + \"=\") {\n        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));\n        break;\n      }\n    }\n  }\n  return cookieValue;\n}\nfunction CSRFToken(): ReactElement {\n  const csrftoken = getCookie(\"csrftoken\");\n  return (\n    <input type=\"hidden\" name=\"csrfmiddlewaretoken\" value={csrftoken ?? \"\"} />\n  );\n}\n\nexport default CSRFToken;\n","import { LineCategory, splitAsTokens } from \"./LineParser\";\n\nfunction splitArrayBySize<T>(array: T[], size: number): T[][] {\n  const result = [] as T[][];\n  for (const element of array) {\n    const last = result[result.length - 1];\n    if (last && last.length < size) {\n      last.push(element);\n    } else {\n      result.push([element]);\n    }\n  }\n  return result;\n}\n\nfunction convertBodyToSlide(body: Body, lineSize = 2): Slide[] {\n  const { tag, lines } = body;\n  return splitArrayBySize(lines, lineSize).map((lines) => ({\n    tag: tag,\n    body: lines.join(\"\\n\"),\n  }));\n}\n\nexport type SongPart = {\n  start: number;\n  end: number;\n  category: LineCategory;\n  lines: string[];\n};\n\nexport type Body = {\n  tag?: string;\n  lines: string[];\n};\n\nexport enum SlideConvertMethod {\n  withFlowOrder,\n  withBodyOrder,\n}\n\nexport type Slide = {\n  tag?: string;\n  body: string;\n};\n\nexport class SongParser {\n  title?: string;\n  flow?: string;\n  linkUrl?: string;\n  bodys: Body[] = [];\n  tagBodyMap = new Map<string, Body>();\n  bodysWithNoTag: Body[] = [];\n  comments: string[] = [];\n\n  private logDiscard(\n    type: string,\n    part: SongPart | string[],\n    lineJoiner = \"\\n\"\n  ) {\n    if (part instanceof Array) {\n      console.error(`${type} part (${part}) is discarded`);\n    } else {\n      console.error(\n        `${type} part (${part.lines.join(lineJoiner)}) is discarded`\n      );\n    }\n  }\n\n  constructor(public songParts: SongPart[]) {\n    let currentTag: string | undefined;\n    for (const part of songParts) {\n      if (part.category === LineCategory.title) {\n        currentTag = undefined;\n        if (this.title === undefined) {\n          this.title = part.lines.join(\"\\n\");\n        } else {\n          this.logDiscard(\"title\", part);\n        }\n      }\n      if (part.category === LineCategory.flow) {\n        currentTag = undefined;\n        if (this.flow === undefined) {\n          this.flow = part.lines.join(\" \");\n        } else {\n          this.logDiscard(\"flow\", part, \" \");\n        }\n      }\n      if (part.category === LineCategory.linkUrl) {\n        currentTag = undefined;\n        if (this.linkUrl === undefined) {\n          this.linkUrl = part.lines.join(\"\\n\");\n        } else {\n          this.logDiscard(\"linkUrl\", part);\n        }\n      }\n      if (part.category === LineCategory.tag) {\n        currentTag = part.lines[0].toUpperCase() || undefined;\n        console.error(\"set current tag\", currentTag);\n        if (part.lines.length > 1) {\n          this.logDiscard(\"tag\", part.lines.slice(1), \", \");\n        }\n      }\n      if (part.category === LineCategory.body) {\n        console.error(\"current tag for body\", currentTag);\n        const lastBody = this.bodys[this.bodys.length - 1];\n        if (lastBody && currentTag && lastBody.tag === currentTag) {\n          lastBody.lines = lastBody.lines.concat(part.lines);\n        } else {\n          this.bodys.push({ tag: currentTag, lines: part.lines });\n        }\n      }\n      if (part.category === LineCategory.comment) {\n        this.comments.push(part.lines.join(\"\\n\"));\n      }\n    }\n\n    this.bodysWithNoTag = this.bodys.filter(($0) => $0.tag === undefined);\n    this.tagBodyMap = new Map(\n      this.bodys\n        .flatMap(({ tag, lines }) => (tag ? [{ tag, lines }] : []))\n        .map(($0) => [$0.tag, $0])\n    );\n  }\n\n  toSlideBodyOrder(): Slide[] {\n    return this.bodys.flatMap(($0) => convertBodyToSlide($0));\n  }\n\n  toSlideFlowOrder(): Slide[] {\n    if (this.flow === undefined) {\n      return this.toSlideBodyOrder();\n    }\n    const flowTokens = splitAsTokens(this.flow).map(($0) => $0.toUpperCase());\n    const bodys = flowTokens.map((token) => {\n      return (token && this.tagBodyMap.get(token)) || token;\n    });\n    const slidesFromFlowTokens: Slide[] = bodys.flatMap((body) => {\n      if (typeof body === \"string\") {\n        return [{ tag: body, body: \"\" }];\n      } else {\n        return convertBodyToSlide(body);\n      }\n    });\n    const slidesFromUntaggedBodys = this.bodysWithNoTag.flatMap(($0) =>\n      convertBodyToSlide($0)\n    );\n    return slidesFromFlowTokens.concat(slidesFromUntaggedBodys);\n  }\n\n  toSlides(\n    method: SlideConvertMethod = SlideConvertMethod.withFlowOrder\n  ): Slide[] {\n    switch (method) {\n      case SlideConvertMethod.withFlowOrder:\n        return this.toSlideFlowOrder();\n      case SlideConvertMethod.withBodyOrder:\n        return this.toSlideBodyOrder();\n      default:\n        return this.toSlideBodyOrder();\n    }\n  }\n\n  toString(): string {\n    return `\n\t\t\t* title: ${this.title}\n\t\t\t* flow: ${this.flow}\n\t\t\t* linkUrl: ${this.linkUrl}\n\t\t\t* bodys: ${this.bodys\n        .map(({ tag, lines }) => `[${tag}]\\n${lines.join(\"\\n\")}`)\n        .join(\"\\n\\n\")}\n\t\t\t* tagBodyMap: ${this.tagBodyMap}\n\t\t\t* bodysWithNoTag: ${this.bodysWithNoTag}\n\t\t\t* comments: ${this.comments}\n\t\t`;\n  }\n}\n","import { SongParser, SongPart } from './SongParser'\nimport { $enum } from 'ts-enum-util'\nimport { Optional } from 'utility-types'\n\nexport enum LineCategory {\n  empty,\n  linkUrl,\n  tag,\n  flow,\n  title,\n  comment,\n  body,\n  date,\n  separator,\n  unknown,\n}\n\nconst tagPatterns = [/^V\\d?$/i, /^P?C\\d?$/i, /^B\\d?$/i, /^E(nding)$/i]\nconst isTag = (arg: string) => tagPatterns.some(pattern => pattern.test(arg))\nexport const flowTokenPatterns = [...tagPatterns, /^x\\d$/i, /^간주$/]\nexport const isFlowToken = (arg: string): boolean =>\n  flowTokenPatterns.some(pattern => pattern.test(arg))\nexport const splitAsTokens = (arg: string): string[] =>\n  arg.split(/[\\W_]/).filter($0 => /\\w/.test($0))\n\nconst separatorPatterns = [/^[-=*][-=* ]+[-=*]$/]\nconst isSeparator = (arg: string) => separatorPatterns.some(pattern => pattern.test(arg))\nconst scoreRange = {\n  certain: 5,\n  notPossible: 0,\n}\n\nconst titleSections = [\n  LineCategory.comment,\n  LineCategory.title,\n  LineCategory.flow,\n  LineCategory.linkUrl,\n]\n\ntype Scorer = (text: string) => number | undefined\nconst categoryScorer: Partial<Record<LineCategory, Scorer>> = {\n  [LineCategory.empty]: text => (text === '' ? scoreRange.certain : scoreRange.notPossible),\n  [LineCategory.date]: text => undefined,\n  [LineCategory.title]: text => {\n    let score = 0\n    if (/^\\d./.test(text)) {\n      score += 2\n    }\n    if (/\\(\\w\\)$/.test(text)) {\n      score += 2\n    }\n    if (/\\(\\w->\\w\\)$/.test(text)) {\n      score += 1\n    }\n    return score\n  },\n  [LineCategory.linkUrl]: text =>\n    /^https?:\\/\\/.*$/.test(text) ? scoreRange.certain : scoreRange.notPossible,\n  [LineCategory.flow]: text => {\n    const tokens = splitAsTokens(text)\n    if (tokens.length === 1) {\n      return scoreRange.notPossible\n    }\n    const flowTokens = tokens.filter(isFlowToken)\n    return Math.ceil((5 * flowTokens.length) / tokens.length)\n  },\n  [LineCategory.tag]: text => {\n    if (isTag(text)) {\n      return scoreRange.certain\n    }\n    if (/^[A-Z]{,2}\\d?$/i.test(text)) {\n      return 3\n    }\n  },\n  [LineCategory.body]: text => {\n    if (/^[\\w,\"'.)( ]+$/i.test(text)) {\n      return 2\n    }\n    return 1\n  },\n  [LineCategory.comment]: text => {\n    if (/[가-힣]+/.test(text)) {\n      return 2\n    }\n    return 1\n  },\n  [LineCategory.separator]: text =>\n    isSeparator(text) ? scoreRange.certain : scoreRange.notPossible,\n}\n\nclass Line {\n  inferedCategory: {\n    value: LineCategory\n    score: number\n  }\n  constructor(public text: string) {\n    const categories = $enum(LineCategory).getValues()\n    this.inferedCategory = categories.reduce((result, current) => {\n      if (result?.score === scoreRange.certain) {\n        return result\n      }\n      const checker = categoryScorer[current]\n      const score = checker?.(text)\n      if (score !== undefined && score > (result?.score ?? -1)) {\n        return { value: current, score: score }\n      }\n      return result\n    }, undefined as { value: LineCategory; score: number } | undefined) ?? {\n      value: LineCategory.unknown,\n      score: 5,\n    }\n  }\n}\n\nexport class LineParser {\n  lines: Line[]\n  private songsCache?: SongParser[]\n  done = false\n  constructor(text: string) {\n    this.lines = text\n      .trim()\n      .split('\\n')\n      .map($0 => $0.trim())\n      .reduce((result, current) => {\n        const lastLine = result[result.length - 1] ?? ''\n        if (!(current === '' && lastLine.text === '')) {\n          result.push(new Line(current))\n        }\n        return result\n      }, [] as Line[])\n  }\n\n  songs(): SongParser[] {\n    if (this.songsCache) {\n      return this.songsCache\n    }\n    const songParts = this.getSongParts()\n    const songs: SongPart[][] = []\n\n    let currentIndex = 0\n    while (currentIndex !== -1 && currentIndex < songParts.length) {\n      const currentPart = songParts[currentIndex]\n      if (currentPart.category === LineCategory.separator) {\n        const previousParts = songParts.slice(0, currentIndex)\n        if (isCompleteSong(previousParts)) {\n          songs.push(previousParts)\n          songParts.splice(0, currentIndex)\n          currentIndex = 1\n          continue\n        }\n      } else if (titleSections.includes(currentPart.category)) {\n        const firstBodyIndexAfterThis = songParts\n          .slice(currentIndex)\n          .findIndex($0 => $0.category === LineCategory.body)\n        const titleEndIndex =\n          firstBodyIndexAfterThis !== -1 ? currentIndex + firstBodyIndexAfterThis : undefined\n        console.error(\n          'current',\n          currentPart.lines,\n          'firstbody',\n          songParts[titleEndIndex ?? -1]?.lines,\n        )\n        if (titleEndIndex !== undefined) {\n          const isTitleSection = (() => {\n            const categories = songParts.slice(currentIndex, titleEndIndex).map($0 => $0.category)\n            console.error(\n              'categories',\n              categories.map($0 => $enum(LineCategory).getKeyOrDefault($0)),\n            )\n            return (\n              categories.includes(LineCategory.title) ||\n              categories.includes(LineCategory.flow) ||\n              categories.includes(LineCategory.linkUrl)\n            )\n          })()\n          console.error('is title section', isTitleSection, '\\n')\n          if (isTitleSection) {\n            const previousParts = songParts.slice(0, currentIndex)\n            if (isCompleteSong(previousParts)) {\n              songs.push(previousParts)\n              songParts.splice(0, currentIndex)\n            }\n            console.error('current index', currentIndex, '->', firstBodyIndexAfterThis)\n            currentIndex = firstBodyIndexAfterThis\n            continue\n          } else {\n            console.error('current index', currentIndex, '->', titleEndIndex)\n            currentIndex = firstBodyIndexAfterThis\n            continue\n          }\n        }\n      }\n      currentIndex += 1\n    }\n    if (isCompleteSong(songParts)) {\n      songs.push(songParts)\n    }\n\n    this.songsCache = songs.map($0 => new SongParser($0))\n    return this.songsCache\n  }\n\n  getSongParts(): SongPart[] {\n    const songParts = [] as Optional<SongPart, 'end' | 'lines'>[]\n    this.lines.forEach((line, index) => {\n      const last = songParts[songParts.length - 1]\n      if (last === undefined) {\n        songParts.push({ start: index, category: line.inferedCategory.value })\n      } else if (last.category !== line.inferedCategory.value) {\n        last.end = index\n        songParts.push({ start: index, category: line.inferedCategory.value })\n      }\n    })\n    if (songParts[songParts.length - 1]) {\n      songParts[songParts.length - 1].end = this.lines.length\n    }\n    return songParts.flatMap(part => {\n      const { start, end, category } = part\n      if (end === undefined) {\n        return []\n      }\n      return [{ start, end, category, lines: this.lines.slice(start, end).map($0 => $0.text) }]\n    })\n  }\n}\n\nfunction isCompleteSong(songParts: SongPart[]): boolean {\n  return songParts.filter($0 => $0.category === LineCategory.body).length > 0\n}\n","import { LineParser } from './LineParser'\nimport { Slide, SlideConvertMethod, SongParser } from './SongParser'\n\nfunction convertSlideToFormText(slide: Slide): string {\n  const { tag, body } = slide\n  return [`[[${tag ?? ''}]]`, body || tag].join('\\n')\n}\nfunction convertSongSlidesToFormText(slides: Slide[]): string {\n  return slides.map(convertSlideToFormText).join('\\n---\\n')\n}\n\nexport class LyricParser {\n  lineParser: LineParser\n  songParsers: SongParser[]\n  constructor(text: string) {\n    this.lineParser = new LineParser(text)\n    this.songParsers = this.lineParser.songs()\n  }\n\n  toFormText(method: SlideConvertMethod = SlideConvertMethod.withFlowOrder): string {\n    return this.songParsers\n      .map($0 => {\n        return convertSongSlidesToFormText($0.toSlides(method))\n      })\n      .join('\\n===\\n')\n  }\n}\n","import React, { useRef } from \"react\";\nimport \"./App.css\";\nimport CSRFToken from \"./api/CSRFToken\";\nimport { LyricParser } from \"./parser/LyricParser\";\n\nfunction App() {\n  const formRef = useRef<HTMLFormElement>(null);\n  const textAreaRef = useRef<HTMLTextAreaElement>(null);\n  const hiddenBodyRef = useRef<HTMLInputElement>(null);\n  const handleButtonClick = (): void => {\n    if (!formRef.current || !textAreaRef.current || !hiddenBodyRef.current) {\n      return;\n    }\n    const value = textAreaRef.current?.value;\n    if (!value) {\n      return;\n    }\n    const parser = new LyricParser(value);\n    const formText = parser.toFormText();\n    hiddenBodyRef.current.value = formText;\n    formRef.current.submit();\n  };\n  return (\n    <div className=\"App\">\n      <form\n        id=\"lyrics_form\"\n        name=\"lyrics_form\"\n        ref={formRef}\n        method=\"post\"\n        action=\"\"\n      >\n        <CSRFToken />\n        <input ref={hiddenBodyRef} type=\"hidden\" name=\"body\"></input>\n      </form>\n      <div>\n        <textarea\n          className=\"form-control\"\n          ref={textAreaRef}\n          id=\"lyrics\"\n        ></textarea>\n        <div>\n          <button className=\"btn btn-primary\" onClick={handleButtonClick}>\n            제출\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}